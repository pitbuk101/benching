"""Module to interface with the Azure function that connects to the PG database."""

import logging
from typing import Any

import requests

from ada.utils.config.config_loader import read_config

log = logging.getLogger(__name__)


class AzureFunctionResponseError(Exception):
    """Raised when there is an error in the response of the Azure Connector response."""


class AzureConnector:
    """Class to interface with PG database via the Azure function.

    Designed to replicate the interface of the psycopg2 cursor and connection objects.
    """

    last_result: Any = None
    config: dict[str, Any] = read_config("azml_deployment.yaml")

    def __init__(
        self,
        azure_pg_connector_url: str,
        cursor_type: object | None = None,
        tenant_key: str = None,
        tenant_id: str = None,
    ):
        """Creates a connector object.
        Args:
            cursor_type: Type of cursor to use. Defaults to None, which is a tuple cursor.
        """
        # We pass on the name of the cursor type to the Azure function, which will then
        # instantiate the correct cursor type on the Azure side.

        self.cursor_type = cursor_type
        if tenant_id is None:
            raise ValueError("`tenant_id` must be provided.")
        self.tenant_id = tenant_id

        if tenant_key is None:
            raise ValueError("`tenant_key` must be provided.")
        self.tenant_key = tenant_key

        self.__endpoint = azure_pg_connector_url

    def execute(self, query: str, values: tuple = None, **kwargs) -> None:
        """
        Pass the query to Azure function and save the response.
        Args:
            query: SQL query to execute, generated by a pg connector method.
            values: Values to be passed to the query.
        """
        execution_body = {
            "query": query,
            "cursor_type": self.cursor_type.__name__ if self.cursor_type else None,
            "tenant_id": self.tenant_id,
            "tenant_key": self.tenant_key,
        }
        if kwargs:
            execution_body["query_kwargs"] = kwargs

        if values:
            execution_body["values"] = list(values)

        response = requests.post(
            f"{self.__endpoint}",
            json=execution_body,
            timeout=60,
        )

        if response.status_code != 200:
            log.error("Received status code: %s", response.status_code)
            log.error("Received response: %s", response.text)
            raise AzureFunctionResponseError(
                "The return status from the Azure function was not "
                "200.\nPlease check the logs for more information."
            )
        try:
            self.last_result = response.json()
        except Exception as exception:
            log.error("Received response: %s", response.text)
            raise AzureFunctionResponseError(
                "The response from the Azure function could not be parsed.\n"
                "Please check the logs for more information."
            ) from exception

    def fetchall(self) -> Any:
        """Retrieve the last result in its entirety."""
        return self.last_result

    def fetchone(self) -> Any:
        """Retrieve only the first record from the last executed query."""
        return self.last_result[0]

    def commit(self):
        """Not implemented for Azure function connector."""

    def close(self):
        """Not implemented for Azure function connector."""
